#!/usr/bin/env python3
# coding: utf-8

"""
  Map (Kvorum) to World (Gazebo) Converter

  05.05.2019, 11.03.2024, 07.12.2024
  Version 1.4
  LP 08.02.2025

"""
import sys, time, math, os
import argparse
from kvorum2 import mapfile
from kvorum2.mapfile import ctl

Title = "map2world 1.4"

def EvalObjects(mobotlaunchname):

    f = open(mobotlaunchname, 'w')

    print('<?xml version="1.0" ?>', file=f)
    print('<model xmlns:xacro="http://www.ros.org/wiki/xacro" name="mobot">', file=f)

    print("<!--", file=f, end='')
    print(f'''
===================================================================================
  This document was autogenerated by map2word from {ctl.mapname}
  EDITING THIS FILE BY HAND IS NOT RECOMMENDED
===================================================================================''', file=f)
    print(file=f)
    print("Project:", ctl.title, file=f)
    print('Source:', ctl.mapname, file=f)
    print('Launch file:', mobotlaunchname, file=f)

    print('Model: dimX = {} dimY = {} step_x = {:3.2f} step_y = {:3.2f}'.format(ctl.dimX, ctl.dimY, ctl.step_x, ctl.step_y), file=f)
    print('Real:  dimX = {} dimY = {} step_x = {:3.2f} step_y = {:3.2f}'.format(ctl.RealdimX, ctl.RealdimY, ctl.Realstep_x, ctl.Realstep_y), file=f)
    print('cellsize:', ctl.cellsize, file=f)

    # Robots positions
    for i in range(ctl.RobotNum):
        x = mapfile.ftr(ctl.RobotX[i]*ctl.Realstep_x  - ctl.RealdimX/2)
        y = mapfile.ftr((ctl.num_lines-ctl.RobotY[i])*ctl.Realstep_y  - ctl.RealdimY/2)
        ctl.RobotX[i] = x
        ctl.RobotY[i] = y

    print(file=f)
    print('Robots positions',file=f)
    print('  _RobotNum_ =', ctl.RobotNum, file=f)
    print('  _RobotX_ =', ctl.RobotX, file=f)
    print('  _RobotY_ =', ctl.RobotY, file=f)
    print('  _RobotA_ =', ctl.RobotA, file=f)
    print("\n-->\n", file=f)

    for e in ctl.OBJECTS:
        e[1] = ctl.num_lines - e[1]
        x = mapfile.ftr(e[0]*ctl.Realstep_x - ctl.RealdimX/2)
        y = mapfile.ftr(e[1]*ctl.Realstep_y - ctl.RealdimY/2)
        code = e[2]
        level = e[3]
        # Препятствие
        if level=='gdic.LEVEL_GROUND':
            x1, y1 = x, y
            x2 = mapfile.ftr(x+ctl.Realstep_x-0.01)
            y2 = mapfile.ftr(y+ctl.Realstep_y-0.01)
            print(f'<xacro:manege x1="{x1}" y1="{y1}" x2="{x2}" y2="{y2}"/>', file=f)
        # Куб
        if code==mapfile.tQube:
            print(f'<xacro:box2 x="{x}" y="{y}"/>', file=f)
        # Цилиндр
        if code==mapfile.tCylinder:
            print(f'<xacro:cyl2 x="{x}" y="{y}"/>', file=f)
        # Пятно
        if code==mapfile.tSpot or level=='gdic.LEVEL_LIGHT':
            print(f'<xacro:spot2 x="{x}" y="{y}"/>', file=f)
        # ArUco
        if level=='gdic.LEVEL_COLOR':
            anum=code
            print(f'<xacro:arucotower anum="{anum}" artype="${{ArucoType}}" x="{x}" y="{y}"/>', file=f)

    if not ctl.env_torus:
        x1, y1 = -ctl.RealdimX/2, -ctl.RealdimY/2
        x2, y2 = ctl.RealdimX/2, ctl.RealdimY/2
        print(f'<xacro:manege x1="{x1}" y1="{y1}" x2="{x2}" y2="{y2}"/>', file=f)
    print(file=f)
    print("</model>", file=f)
    f.close()

#===============================================================================
#
# Формируем aruco launch-файл
#
#===============================================================================
def generate_aruco_launch(launchname):
    if launchname is None: return
    outf = open(launchname, 'w')

    print(f'''<!--
===================================================================================
This file was autogenerated by map2word from {ctl.mapname}
  EDITING THIS FILE BY HAND IS NOT RECOMMENDED
===================================================================================
  aruco_server

  aruco_server.py - -input /usb_cam/image_raw - -topic superlocator - -rid robot_id - -nowindow - -nooutput
  (только уберите лишний пробел между '- -')

  Аргументы launch-файла:
  "tmr"    - инерционность, такты
  "msize"  - размер ArUco-маркера, м. (0.03)
  "input"  - имя входного топика (видео)
  "topic"  - имя выходного топика
  "rid"    - id робота
  "camang" - угол раствора камеры (120)

  roslaunch gmodctl aruco.launch msize:=0.04

optional arguments:
  - -input inptopic  input topic name, example: /usb_cam/image_raw
  - -topic outtopic  output topic name
  - -cfg config      config file, default is "cfg/camera"
  - -nowindow        use only console, without image window
  - -nooutput        don't output
  - -rid             robot`s id (default is 1)
  - -tmr             TMR value (default is 100)
  - -camang          camera angle, grad (default is 120)
  - -width           image width (default is 640)
  - -msize           ArUco marker size, m (default is 0.03)
  - -rfreq           ROS rate, Hz (default is 10)
-->

<launch>

  <arg name="tmr" default="10"/>
  <arg name="msize" default="0.03"/>
  <arg name="topic" default="superlocator"/>
  <arg name="input" default="/usb_cam/image_raw"/>
  <arg name="rid" default=""/>
  <arg name="camang" default="120"/>''', file=outf)

    for i in range(ctl.RobotNum):
        print(f'''
  <node name="aruco_server_node{i+1}" pkg="yyctl" type="aruco_server.py" output="screen"
        args="--input /group_mobot{i+1}/mobot{i+1}/camera1/image_raw --topic superlocator{i+1} --rid {i+1} --tmr $(arg tmr) --msize $(arg msize) --camang $(arg camang) --nowindow --nooutput" />''', file=outf)

    print("\n</launch>", file=outf)
    outf.close()

#===============================================================================
#
# Формируем bridge launch-файл
#
#===============================================================================
def generate_bridge_launch(launchname):
    if launchname is None: return
    outf = open(launchname, 'w')

    print(f'''<!--
===================================================================================
This file was autogenerated by map2word from {ctl.mapname}
  EDITING THIS FILE BY HAND IS NOT RECOMMENDED
===================================================================================
  Запуск mobot_du_kvorum_bridge_node
  Много аргументов

  roslaunch mobot_du_kvorum_bridge.launch
  roslaunch mobot_du_kvorum_bridge.launch compass:=-60
  roslaunch mobot_du_kvorum_bridge.launch compass:=-60 rotvang:=0.075 cellsize:=0.3
  roslaunch mobot_du_kvorum_bridge.launch log:= - -log
    ...
-->

<launch>
  <arg name="log" default="" />
  <arg name="compass" default="0" />

  <arg name="cspeed"   default="0.75" />
  <arg name="rotvlin"  default="0.01" />
  <arg name="rotvang"  default="0.1" />
  <arg name="cellsize" default="1" />''', file=outf)

    for i in range(ctl.RobotNum):
        print(f'''
  <node name="mobot_du_kvorum_bridge_node{i+1}" pkg="gmodctl" type="mobot_du_kvorum_bridge.py" output="screen"
              args="--rid {i+1} --cfg $(find gmodctl)/scripts/config/robot.cfg $(arg log)">

    <param name="compass" type="int" value="$(arg compass)" />

    <param name="cspeed" type="double" value="$(arg cspeed)" />
    <param name="rotvlin" type="double" value="$(arg rotvlin)" />
    <param name="rotvang" type="double" value="$(arg rotvang)" />
    <param name="cellsize" type="double" value="$(arg cellsize)" />
  </node>''', file=outf)

    print("\n</launch>", file=outf)
    outf.close()

#===============================================================================
#
# Формируем rctl launch-файл
#
#===============================================================================
def generate_rctl_launch(launchname):
    if launchname is None: return
    outf = open(launchname, 'w')

    print(f'''<!--
===================================================================================
This file was autogenerated by map2word from {ctl.mapname}
  EDITING THIS FILE BY HAND IS NOT RECOMMENDED
===================================================================================
  Запуск ctl-curs
  ctl-curs.py
-->

<launch>''', file=outf)
    for i in range(ctl.RobotNum):
        print(f'''
  <node name="gmodctl_node{i+1}" pkg="gmodctl" type="ctl-curs.py" output="screen"
    args="--rid {i+1} --cfg $(find gmodctl)/scripts/config/robot.cfg" />''', file=outf)

    print("\n</launch>", file=outf)
    outf.close()

#===============================================================================
#
# Формируем mobot launch-файл
#
#===============================================================================
def generate_mobot_launch(launchname):
    if launchname is None: return
    outf = open(launchname, 'w')

    print(f'''<!--
===================================================================================
This file was autogenerated by map2word from {ctl.mapname}
  EDITING THIS FILE BY HAND IS NOT RECOMMENDED
===================================================================================
-->
<launch>

  <env name="GAZEBO_RESOURCE_PATH" value="$(find mobot_du):$(optenv GAZEBO_RESOURCE_PATH)"/>
  <env name="GAZEBO_RESOURCE_PATH" value="$(find polygone_mobot):$(optenv GAZEBO_RESOURCE_PATH)"/>

  <arg name="ROBOT_MODEL_NAME" value="$(find mobot_du)"/>
  <arg name="WORLD_MODEL_NAME" value="$(find polygone_mobot)"/>

  <arg name="robot_name" default="mobot1"/>

  <arg name="pos_x" default="2.75"/>
  <arg name="pos_y" default="1.75"/>
  <arg name="pos_z" default="0.25"/>

  <arg name="roll" default="0"/>
  <arg name="pitch" default="0"/>
  <arg name="yaw" default="0"/>

  <!--
    Полигон
  -->
  <include file="$(arg WORLD_MODEL_NAME)/launch/world.launch"/>

  <!--
    Роботы
    Set different initial poses to avoid collision when spawning the model
  -->''', file=outf)

    for i in range(ctl.RobotNum):

        x = ctl.RobotX[i]
        y = ctl.RobotY[i]
        z = 0.1
        yaw = math.radians(ctl.RobotA[i])
        name = f"mobot{i+1}"

        print(f'''
  <include file="$(arg ROBOT_MODEL_NAME)/launch/robot.launch">
    <arg name="robot_name" value="{name}"/>
    <arg name="robot_id" value="{i+1}"/>
    <arg name="pos_x" value="{x}"/>
    <arg name="pos_y" value="{y}"/>
    <arg name="pos_z" value="{z}"/>
    <arg name="yaw" value="{yaw}"/>
    <arg name="pitch" value="0"/>
    <arg name="roll" value="0"/>
  </include>''', file=outf)

    print("</launch>", file=outf)
    outf.close()

#===============================================================================
#
# Формируем servolocator launch-файл
#
#===============================================================================
def generate_servolocator_launch(launchname):
    if launchname is None: return
    outf = open(launchname, 'w')

    print(f'''<!--
===================================================================================
This file was autogenerated by map2word from {ctl.mapname}
  EDITING THIS FILE BY HAND IS NOT RECOMMENDED
===================================================================================
  Запуск servoctl
  servoctl.py
-->

<launch>''', file=outf)

    for i in range(ctl.RobotNum):
        print(f'''
  <node name="servoctl_node{i+1}" pkg="gmodctl" type="servoctl.py" output="screen"
    args="--rid {i+1} --cfg $(find gmodctl)/scripts/config/robot.cfg" />''', file=outf)

    print("\n</launch>", file=outf)
    outf.close()
#===============================================================================
#
# main
#
#===============================================================================
def main(mapname, resname, mobotlaunchname, arucolaunchname, bridgelaunchname, rctllaunchname, servolocatorlaunchname, cellsize):

    print(f"-- processing {mapname}")

    mapfile.ReadMap(mapname)
    ctl.cellsize = cellsize
    ctl.RealdimX = ctl.dimX*cellsize
    ctl.RealdimY = ctl.dimY*cellsize
    ctl.Realstep_x = ctl.step_x*cellsize
    ctl.Realstep_y = ctl.step_y*cellsize
    
    # Убираем дубли
    OBJ2 = []
    for i1 in range(len(ctl.OBJECTS)):
        x1, y1, code1, level1 = ctl.OBJECTS[i1][0], ctl.OBJECTS[i1][1], ctl.OBJECTS[i1][2], ctl.OBJECTS[i1][3]
        found = False
        for i2 in range(len(ctl.OBJECTS)):
            if i1==i2: continue
            x2, y2, code2, level2 = ctl.OBJECTS[i2][0], ctl.OBJECTS[i2][1], ctl.OBJECTS[i2][2], ctl.OBJECTS[i2][3]
            if x1==x2 and y1==y2 and level1=='gdic.LEVEL_GROUND':
                found = True
                break
        if not found:
            OBJ2.append(ctl.OBJECTS[i1])
    ctl.OBJECTS = OBJ2
    print(f"-- number of objects after filtering = {len(ctl.OBJECTS)}")

    EvalObjects(resname)

    #===========================================================================

    # Формируем mobot launch-файл
    generate_mobot_launch(mobotlaunchname)

    # Формируем aruco launch-файл
    generate_aruco_launch(arucolaunchname)

    # Формируем bridge launch-файл
    generate_bridge_launch(bridgelaunchname)

    # Формируем rctl launch-файл
    generate_rctl_launch(rctllaunchname)

    # Формируем servolocator launch-файл
    generate_servolocator_launch(servolocatorlaunchname)

#===============================================================================
#
#
#
#===============================================================================
if __name__ == '__main__':

    parser = argparse.ArgumentParser(prog = '', description = 'Title', epilog = '')
    parser.add_argument ('--map', default=None, required=True, metavar = 'mapfile', help = 'input map-file')
    parser.add_argument ('--inc', default=None, required=True, metavar = 'incfile', help = 'output inc-file')
    parser.add_argument ('--launchmobot', default=None, required=True, metavar = 'mobot_launch', help = 'output mobot launch-file')
    parser.add_argument ('--launcharuco', default=None, required=True, metavar = 'aruco_launch', help = 'output aruco launch-file')
    parser.add_argument ('--launchbridge', default=None, required=True, metavar = 'bridge_launch', help = 'output bridge launch-file')
    parser.add_argument ('--launchrctl', default=None, required=False, metavar = 'rctl_launch', help = 'output rctl launch-file')
    parser.add_argument ('--launchsrv', default=None, required=False, metavar = 'servolocator_launch', help = 'output servolocator launch-file')
    parser.add_argument ('--cellsize', type=float, default=None, required=True, metavar = 'cellsize', help = 'Kvorum/Gazebo cellsize. "--cellsize 0.3" means: Gazebo size in meters = DimXY*cellsize')

    namespace = parser.parse_args(sys.argv[1:])
    print(namespace)

    main(namespace.map, namespace.inc, namespace.launchmobot, namespace.launcharuco, namespace.launchbridge, namespace.launchrctl, namespace.launchsrv, namespace.cellsize)
